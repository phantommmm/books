# Mysql主从复制

## 流程

(1) Master 将数据改变记录到二进制日志(binary log)中

(2) Slave 通过 I/O 线程读取 Master 中的 binary log events 并写入到它的中继日志(relay log)； 

(3) Slave 重做中继日志中的事件，把中继日志中的事件信息一条一条的在本地执行一次，完成数据在本地的存储，从而实现将改变反映到它自己的数据(数据重放)。


<img src="https://img-blog.csdn.net/20160425105401063?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom:50%;" />

**MySQL 对于二进制日志 (binlog)的复制类型** 

(1) 基于语句的复制：在 Master 上执行的 SQL 语句，在 Slave 上执行同样的语句。MySQL 默 认采用基于语句的复制，效率比较高。一旦发现没法精确复制时，会自动选着基于行的复制。 

(2) 基于行的复制：把改变的内容复制到 Slave，而不是把命令在 Slave 上执行一遍。从MySQL5.0 开始支持。

 (3) 混合类型的复制：默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。

**好处**

①避免数据库单点故障：主服务器实时、异步复制数据到从服务器，当主数据库宕机时，可在从数据库中选择一个升级为主服务器，从而防止数据库单点故障。

②提高査询效率：根据系统数据库访问特点，可以使用主数据库进行数据的插入、删除及更新等写操作，而从数据库则专门用来进行数据査询操作，从而将査询操作分担到不同的从服务器以提高数据库访问效率。

## 主从不同步情况

1. 网络的延迟
   由于mysql主从复制是基于binlog的一种异步复制
   通过网络传送binlog文件，理所当然网络延迟是主从不同步的绝大多数的原因，特别是跨机房的数据同步出现这种几率非常的大，所以做读写分离，注意从业务层进行前期设计。

2. 主从两台机器的负载不一致
   由于mysql主从复制是主数据库上面启动1个io线程，而从上面启动1个sql线程和1个io线程，当中任何一台机器的负载很高，忙不过来，导致其中的任何一个线程出现资源不足，都将出现主从不一致的情况。

3. 版本不一致

   特别是高版本是主，低版本为从的情况下，主数据库上面支持的功能，从数据库上面不支持该功能

## 异步复制

在异步复制中，主库执行完操作后，写入binlog日志后，就返回客户端，这一动作就结束了，并不会验证从库有没有收到，完不完整，所以这样可能会造成数据的不一致。

**主要问题**，在复制过程当中，主库不会去验证Binlog有没有成功复制到从库，那如果主库提交一个事务并写入Binlog中后，当从库还没有从主库得到Binlog时，主库宕机了或因磁盘损坏等故障导致该事务的Binlog丢失了，那从库就不会得到这个事务，也就造成了主从数据的不一致。

## 半同步复制

**当主库每提交一个事务后，不会立即返回，而是等待其中一个从库接收到Binlog并成功写入Relay-log中才返回客户端** 所以这样就保证了一个事务至少有两份日志，一份保存在主库的Binlog，另一份保存在其中一个从库的Relay-log中，从而保证了数据的安全性和一致性。

在半同步复制时，如果主库的一个事务提交成功了，在推送到从库的过程当中，从库宕机了或网络故障，导致从库并没有接收到这个事务的Binlog，此时主库会等待一段时间，如果这个时间过后还无法推送到从库，那MySQL会**自动从半同步复制切换为异步复制**，**当从库恢复正常连接到主库后，主库又会自动切换回半同步复制。**

## 全同步复制

指当主库执行完一个事务，**所有的从库都执行了该事务**才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。

当主库提交事务之后，所有的从库节点必须收到、APPLY并且提交这些事务，然后主库线程才能继续做后续操作。但缺点是，主库完成一个事务的时间会被拉长，性能降低。

## 5.6并行复制

**普通模式问题**

SQL线程只有一个，在主库压力大的时候，备库单个SQL线程是跑不过主库的多个用户线程的，这样备库延迟是不可避免的。为了解决这种n对1造成的备库延迟问题，5.6 引入了并行复制机制，即SQL线程在执行的时候可以并发跑，**分库并行**



**注意 一下的Coordinator线程其实是上面的SQL线程**

### 并行原则

1. 并行执行的基本模型是生产者-消费者，C线程将event按db插入各W线程的任务队列，W线程从队列里取出event执行； ![MTS 并行复制模型](http://mysql.taobao.org/monthly/pic/2015-08-09/mts-model.png)
2. 同一个group(事务)内的event都发给同一个worker，保证事务的一致性；
3. 分发关系由包含db信息的event(G-evnet)决定，其它event按决定好的关系进行分发；

**单库**

coordinator线程分配事件时以事务为单位，一个事务会分配给该事务中第一个库所绑定worker线程，不会被拆分。如果遇到一个新的库，不能按照上面的规则决定执行的数据库的（即没有绑定线程，而且是该事务中第一个库）则会寻找绑定库最少的worker线程来执行它。

**多库**

再来看涉及多库操作的语句，在分配这个语句时，coordinator线程会等待这些库的绑定线程都执行完毕，然后再分配这个语句。而如果涉及到的库太多（大于254）或者是一个ddl语句，则会触发一次同步操作，即等待所有线程执行完毕，然后将它分配给0号worker线程。

### 问题

5.6 的MTS是按db来进行分发的，分发粒度太大，如果只有一个db的时候，就没有并发性了，所有group都分给一个worker，就变成单线程执行了。一个简单的优化改进是改成按table来分发，只需要把分发的key从dbname改成dbname + tablename，整体分发逻辑不需要变动。

## 5.7并行复制

