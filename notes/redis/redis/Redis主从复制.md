## Redis主从复制
作用：

    1.数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
    
    2.故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
    
    3.负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，
    由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；
    尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
    
    4.高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。
         
相关操作：

        1.配置从redis       slaveof 主redis ip 主redis 端口
                            slave 192.168.101.3 6379
        2.断开主从复制   在slave 6379节点：slaveof no one
        3.数据重要节点，使用密码验证 requirepass xxxx
        4.从节点建议用只读模式    slave-read-only=yes, 若从节点修改数据，主从数据不一致
        5.传输延迟：主从一般部署在不同机器上，复制时存在网络延时问题，redis提供 repl-disable-tcp-nodelay    参数决定是否关闭TCP_NODELAY,默认为关闭
        参数关闭时：无论大小都会及时发布到从节点，占带宽，适用于主从网络好的场景，
        参数启用时：主节点合并所有数据成TCP包节省带宽，默认为40毫秒发一次，取决于内核，主从的同步延迟40毫秒，适用于网络环境复杂或带宽紧张，如跨机房

实现原理：
### 1.连接建立阶段 
#### 1）保存主节点信息（子服务器维护 masterhost masterport字段）
    注意：slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端（子客户端）直接返回OK，
    实际的复制操作在这之后才开始进行。           
#### 2）建立socket连接
    从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。
    如果连接成功，则：

    从节点：为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。

    主节点：接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。  
#### 3）发送ping命令
    从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。

    从节点发送ping命令后，可能出现3种情况：
    
    （1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。
    
    （2）超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。
    
    （3）返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。                                                     
#### 4）身份验证
    如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。
    从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。

    如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。
#### 5）发送从节点端口信息    
    身份验证之后，从节点会向主节点发送其监听的端口号（子节点端口6380），主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。
### 2.数据同步阶段（全量复制 部分复制）
    数据同步，可以理解为从节点数据的初始化。具体执行的方式是：从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步。

    在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。
    原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。        
### 3.命令传播阶段（心跳机制）
    主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。
延迟与不一致

    命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；
    因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。
    数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。
    
    repl-disable-tcp-nodelay no：该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。
    当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。
    一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。
    
### 全量复制（sync）与部分复制 (psync)      
#### 1.全量复制：子服务器重启或者Redis2.8之前版本的断线重连都会进行全量同步。
    slave启动或者slave断开重连master的时候，slave会发生SYNC命令给master，master接收到该命令后，则会通过bgsave启动一个子进程将当前时间点的master全部数据的快照写到一个RDB文件中，
    然后发送给slave。slave接收到之后则清空内存，载入这些数据。
##### 执行过程  
    （1）从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行部分复制，就开启全量复制

    （2）主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令
    
    （3）主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据（内存），然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态，
        此期间会阻塞客户端的请求（即正在载入RDB文件时，客户端阻塞）
    
    （4）主节点将前述复制缓冲区中的所有写命令（以Redis命令协议形式，如DEL,SET）发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态
        在slave接受master缓存区命令并执行的过程中，可以同时接受客户端的请求
    
    （5）如果从节点开启了AOF，则会触发bgrewriteaof（异步执行一个 AOF文件重写操作）的执行，从而保证AOF文件更新至主节点的最新状态
#### 总结
    （1）主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的；

    （2）主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗

    （3）从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗
#### 2.部分复制：Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。  
##### 复制偏移量(offset) 
    主节点和从节点分别维护一个复制偏移量（offset），代表的是主节点向从节点传递的字节数；
    主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。
    
    offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。
    例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。
##### 复制积压缓存区
    复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB；
    当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。

    在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。
    由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。
    
    由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。
    反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；
    例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。
    
    从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：
    
    如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；
    如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。
##### 服务器运行ID（runid）
每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)，由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。通过info Server命令，可以查看节点的runid：

        主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制：

    如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；
    如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。          
### 主从节点决定是全量复制还是部分复制流程
    1）首先，从节点根据当前状态，决定如何调用psync命令：

    如果从节点之前未执行过slaveof或最近执行了slaveof no one，则从节点发送命令为psync ? -1，向主节点请求全量复制；
    如果从节点之前执行了slaveof，则发送命令为psync <runid> <offset>，其中runid为上次复制的主节点的runid，offset为上次复制截止时从节点保存的复制偏移量。
    （2）主节点根据收到的psync命令，及当前服务器状态，决定执行全量复制还是部分复制：
    
    如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送sync命令执行全量复制；
    如果主节点版本够新，且runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；
    如果主节点版本够新，但是runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复+FULLRESYNC <runid> <offset>，表示要进行全量复制，其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。
#### 心跳机制（命令传播阶段）：PING和REPLCONF ACK
##### 主-->从:PING
        每隔指定的时间，主节点会向从节点发送PING命令，这个PING命令的作用，主要是为了让从节点进行超时判断。

        PING发送的频率由repl-ping-slave-period参数控制，单位是秒，默认值是10s。
##### 从-->主:  REPLCONF ACK
    从节点会向主节点发送REPLCONF ACK命令，频率是每秒1次；命令格式为：REPLCONF ACK {offset(子节点保存的复制偏移量)} 
 REPLCONF ACK 作用： 
    
    （1）实时监测主从节点网络状态：该命令会被主节点用于复制超时的判断。
    此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1，

    （2）检测命令丢失：从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。
    注意，offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。
    
    （3）辅助保证从节点的数量和延迟：Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令；
    所谓不安全，是指从节点数量太少，或延迟过高。
    例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。     
## 应用中的问题
### 1. 读写分离（主写子读）及其中的问题    
#### （1）延迟与不一致
优化措施：

    1.优化主从节点之间的网络环境（如在同机房部署）；
    2.监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；
    3.使用集群同时扩展写负载和读负载等。
#### （2）数据过期问题
    在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。
    由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。

    Redis 3.2中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题。
### 2. 复制超时问题：导致复制中断的最重要的原因之一
##### 超时判断机制意义
    （1）如果主节点判断连接超时，其会释放相应从节点的连接，从而释放各种资源，否则无效的从节点仍会占用主节点的各种资源（输出缓冲区、带宽、连接等）；
        此外连接超时的判断可以让主节点更准确的知道当前有效从节点的个数，有助于保证数据安全（配合前面讲到的min-slaves-to-write等参数）。

    （2）如果从节点判断连接超时，则可以及时重新建立连接，避免与主节点数据长期的不一致。 
##### 判断机制
    主从复制超时判断的核心，在于repl-timeout参数，该参数规定了超时时间的阈值（默认60s），对于主节点和从节点同时有效；主从节点触发超时的条件分别如下：

    （1）主节点：每秒1次调用复制定时函数replicationCron()，在其中判断当前时间距离上次收到各个从节点REPLCONF ACK的时间，是否超过了repl-timeout值，如果超过了则释放相应从节点的连接。
    
    （2）从节点：从节点对超时的判断同样是在复制定时函数中判断，基本逻辑是：
    
    如果当前处于连接建立阶段，且距离上次收到主节点的信息的时间已超过repl-timeout，则释放与主节点的连接；
    如果当前处于数据同步阶段，且收到主节点的RDB文件的时间超时，则停止数据同步，释放连接；
    如果当前处于命令传播阶段，且距离上次收到主节点的PING命令或数据的时间已超过repl-timeout值，则释放与主节点的连接。
### 其他实际问题
    （1）数据同步阶段：在主从节点进行全量复制bgsave时，主节点需要首先fork子进程将当前数据保存到RDB文件中，然后再将RDB文件通过网络传输到从节点。
    如果RDB文件过大，主节点在fork子进程+保存RDB文件时耗时过多，可能会导致从节点长时间收不到数据而触发超时；此时从节点会重连主节点，然后再次全量复制，再次超时，再次重连……这是个悲伤的循环。
    为了避免这种情况的发生，除了注意Redis单机数据量不要过大，另一方面就是适当增大repl-timeout值，具体的大小可以根据bgsave耗时来调整。

    （2）命令传播阶段：如前所述，在该阶段主节点会向从节点发送PING命令，频率由repl-ping-slave-period控制；该参数应明显小于repl-timeout值(后者至少是前者的几倍)。
    否则，如果两个参数相等或接近，网络抖动导致个别PING命令丢失，此时恰巧主节点也没有向从节点发送数据，则从节点很容易判断超时。

    （3）慢查询导致的阻塞：如果主节点或从节点执行了一些慢查询（如keys *或者对大数据的hgetall等），导致服务器阻塞；阻塞期间无法响应复制连接中对方节点的请求，可能导致复制超时。           
### 3.复制中断问题
#### 复制缓存区溢出导致复制中断
    在全量复制阶段，主节点会将执行的写命令放到复制缓冲区中，
    该缓冲区存放的数据包括了以下几个时间段内主节点执行的写命令：bgsave生成RDB文件、RDB文件由主节点发往从节点、从节点清空老数据并载入RDB文件中的数据。
    当主节点数据量较大，或者主从节点之间网络延迟较大时，可能导致该缓冲区的大小超过了限制，此时主节点会断开与从节点之间的连接；这种情况可能引起全量复制->复制缓冲区溢出导致连接中断->重连->全量复制->复制缓冲区溢出导致连接中断……的循环。
解决：

    复制缓冲区的大小由client-output-buffer-limit slave {hard limit} {soft limit} {soft seconds}配置
    默认值为client-output-buffer-limit slave 256MB 64MB 60，其含义是：如果buffer大于256MB，或者连续60s大于64MB，则主节点会断开与该从节点的连接。
    该参数是可以通过config set命令动态配置的（即不重启Redis也可以生效）
    
    复制缓冲区是客户端输出缓冲区的一种，主节点会为每一个从节点分别分配 复制缓冲区 ；而 复制积压缓冲区 则是一个主节点只有一个，无论它有多少个从节点。
    
### 4. 各场景下复制的选择及优化技巧
#### 主节点重启
     1.主节点宕机： 应进行故障转移处理，将其中的一个从节点升级为主节点，其他从节点从新的主节点进行复制；且故障转移应尽量的自动化，后面文章将要介绍的哨兵便可以进行自动的故障转移。
     
     2.安全重启（debug reload）:主节点内存碎片率过高，或者希望调整一些只能在启动时调整的参数
       
        1)重启后，主节点的runid和offset都不受影响，避免了全量复制。   
        2)它会清空当前内存中的数据，重新从RDB文件中加载，这个过程会导致主节点的阻塞，因此也需要谨慎。 
#### 网络中断
    如果主从节点之间出现网络问题，造成短时间内网络中断，可以分为多种情况讨论。

    第一种情况：网络问题时间极为短暂，只造成了短暂的丢包，主从节点都没有判定超时（未触发repl-timeout）；此时只需要通过REPLCONF ACK来补充丢失的数据即可。

    第二种情况：网络问题时间很长，主从节点判断超时（触发了repl-timeout），且丢失的数据过多，超过了复制积压缓冲区所能存储的范围；此时主从节点无法进行部分复制，只能进行全量复制。
    为了尽可能避免这种情况的发生，应该根据实际情况适当调整复制积压缓冲区的大小；此外及时发现并修复网络中断，也可以减少全量复制。

    第三种情况：介于前述两种情况之间，主从节点判断超时，且丢失的数据仍然都在复制积压缓冲区中；此时主从节点可以进行部分复制。        
                       

