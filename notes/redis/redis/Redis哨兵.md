## Redis哨兵   
基于Redis主从复制，主要作用便是解决主节点故障恢复的自动化问题，进一步提高系统的高可用性。

1)Redis 2.8版本开始引入。哨兵的核心功能是主节点的自动故障转移   

    主要功能:
    
            1.监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常，哨兵之间也会相互监控。
            2.自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。
            3.配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。
            4.通知（Notification）：哨兵可以将故障转移的结果发送给客户端。
                其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置提供者和通知功能，则需要在与客户端的交互中才能体现                
                      客户端即通过java程序等API访问
2)组成部分：
    
            哨兵节点：哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的redis节点，不存储数据。
            数据节点（普通节点）：主节点和从节点都是数据节点。                  
#### 部署
    1.部署主从节点
    2.部署哨兵节点，哨兵启动方式：      redis-sentinel sentinel-26379.conf
                                    redis-server sentinel-26379.conf 
                                    info sentinel查看哨兵信息
#### 故障转移
       主节点6379 子节点6380 6381
        1.主节点故障 
        2.哨兵发现并将子节点6380作为主节点（需要一段时间）同时 将6379置为6380的子节点
        3.虽然6379已挂，但因为哨兵不会对子节点客观下线 所以6380有2个子节点 6379 和 6381 
        4.配置文件改写，新的主节点没有了slaveof配置，其从节点则slaveof新的主节点。                    
#### 总结
    1.每个哨兵节点，只需要配置监控主节点，便可以自动发现其他的哨兵节点和从节点。
    
    2.一个哨兵可以监控多个主节点，通过配置多条sentinel monitor即可实现。                      
#### 客户端访问哨兵系统（配置提供者和通知）
    public static void testSentinel() throws Exception {
         String masterName = "mymaster";
         Set<String> sentinels = new HashSet<>();
         sentinels.add("192.168.92.128:26379");
         sentinels.add("192.168.92.128:26380");
         sentinels.add("192.168.92.128:26381");
 
         JedisSentinelPool pool = new JedisSentinelPool(masterName, sentinels); //初始化过程做了很多工作
         Jedis jedis = pool.getResource();//即连接到了mymaster这个节点 之后的操作都是操作mymaster这个节点
         jedis.set("key1", "value1");
         pool.close();
    }               
    
    主要工作：JedisSentinelPool的构造器
                （1）遍历哨兵节点，获取主节点信息：
                     遍历哨兵节点，通过其中一个哨兵节点+masterName获得主节点的信息；该功能是通过调用哨兵节点的sentinel get-master-addr-by-name命令实现
                
                命令实例：
                192.168.92.128:26379> sentinel get-master-addr-by-name mymaster
                1)"192.168.92.128"
                2)"6380"
                
                一旦获得主节点信息，停止遍历（因此一般来说遍历到第一个哨兵节点，循环就停止了）。      
                
                (2）增加对哨兵的监听：这样当发生故障转移时，客户端便可以收到哨兵的通知，从而完成主节点的切换。
                具体做法是：利用redis提供的发布订阅功能，为每一个哨兵节点开启一个单独的线程，订阅哨兵节点的+switch-master频道，当收到消息时，重新初始化连接池。      
                      
#### 总结
        1）配置提供者:客户端可以通过哨兵节点+masterName获取主节点信息,并连接到主节点   
        2) 通知：哨兵节点在故障转移后，会将新的主节点信息发送给客户端，以便客户端更改连接
#### 哨兵节点命令
    1)基础查询:  info sentinel：获取监控的所有主节点的基本信息
                sentinel masters：获取监控的所有主节点的详细信息
                sentinel master mymaster：获取监控的主节点mymaster的详细信息
                sentinel slaves mymaster：获取监控的主节点mymaster的从节点的详细信息
                sentinel sentinels mymaster：获取监控的主节点mymaster的哨兵节点的详细信息
                sentinel get-master-addr-by-name mymaster：获取监控的主节点mymaster的地址信息，前文已有介绍
                sentinel is-master-down-by-addr：哨兵节点之间可以通过该命令询问主节点是否下线，从而对是否客观下线做出判断
    2）增加/移除对主节点的监控
    
                sentinel monitor mymaster 192.168.92.128 6379 2
                该哨兵节点监控192.168.92.128:6379这个主节点，设置该主节点的名称是mymaster。
                最后的2的含义与主节点的故障判定有关：至少需要2个哨兵节点同意，才能判定主节点故障并进行故障转移。
                
                sentinel remove mymaster：取消当前哨兵节点对主节点mymaster的监控
    
    3）强制故障转移
    
                 sentinel failover mymaster：该命令可以强制对mymaster执行故障转移，即便当前的主节点运行完好；
                 例如，如果当前主节点所在机器即将报废，便可以提前通过failover命令进行故障转移。            
### 基本原理
    （1）定时任务：每个哨兵节点维护了3个定时任务。定时任务的功能分别如下：
             1.通过向主从节点发送info命令获取最新的主从结构；
             
             2.通过发布订阅功能获取其他哨兵节点的信息:
                 对于每个主节点或从节点，都有一个频道：__sentinel__:hello；每个哨兵都订阅该频道，且可以向该频道发送信息；
                 最终的效果就是，每个哨兵向该频道发送消息时，其他哨兵都能接收到，从而实现了哨兵之间的互相发现。
                 
             3.通过向其他节点发送ping命令进行心跳检测，判断是否下线。

    （2）主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。
            顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线；与主观下线相对应的是客观下线。

    （3）客观下线：哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。

        需要特别注意的是，客观下线是主节点才有的概念；如果子节点和哨兵节点发生故障，被哨兵主观下线后，就直接没了，不会再有后续的客观下线和故障转移操作。
                        
    （4）选举领导者哨兵节点：当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。

        监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；
        Raft算法的基本思路是先到先得：即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。选举的具体过程这里不做详细描述，一般来说，哨兵选择的过程很快，谁先完成客观下线，一般就能成为领导者。
        
    （5）故障转移：选举出的领导者哨兵，开始进行故障转移操作，该操作大体可以分为3个步骤：
        
        1.在从节点中选择新的主节点：选择的原则是，首先过滤掉不健康的从节点；然后选择优先级最高的从节点(由slave-priority指定)；
        如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点。
        
        2.更新主从状态：通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。
        
        3.将已经下线的主节点(即6379)设置为新的主节点的从节点，当6379重新上线后，它会成为新的主节点的从节点。   
#### 配置
        （1） sentinel monitor {masterName} {masterIp} {masterPort} {quorum}
              配置哨兵: quorum 建议取值为哨兵数量的一半加1。
        
        （2） sentinel down-after-milliseconds {masterName} {time}
        
              与主观下线的判断有关：哨兵使用ping命令对其他节点进行心跳检测，如果其他节点超过down-after-milliseconds配置的时间没有回复，哨兵就会将其进行主观下线。
              该配置对主节点、从节点和哨兵节点的主观下线判定都有效。
        
              默认值是30000，即30s；可以根据不同的网络环境和应用要求来调整：值越大，对主观下线的判定会越宽松，好处是误判的可能性小，坏处是故障发现和故障转移的时间变长，客户端等待的时间也会变长。
              例如，如果应用对可用性要求较高，则可以将值适当调小，当故障发生时尽快完成转移；如果网络环境相对较差，可以适当提高该阈值，避免频繁误判。
        
        （3） sentinel parallel-syncs {masterName} {number}
        
              与故障转移之后从节点的复制有关：它规定了每次向新的主节点发起复制操作的从节点个数。
              例如，假设主节点切换完成之后，有3个从节点要向新的主节点发起复制；如果parallel-syncs=1，则从节点会一个一个开始复制；如果parallel-syncs=3，则3个从节点会一起开始复制。
        
              parallel-syncs取值越大，从节点完成复制的时间越快，但是对主节点的网络负载、硬盘负载造成的压力也越大；应根据实际情况设置。
              例如，如果主节点的负载较低，而从节点对服务可用的要求较高，可以适量增加parallel-syncs取值。
              
              parallel-syncs的默认值是1。
        
        （4） sentinel failover-timeout {masterName} {time}
        
              与故障转移超时的判断有关，但是该参数不是用来判断整个故障转移阶段的超时，而是其几个子阶段的超时，
              例如如果主节点晋升从节点时间超过timeout，或从节点向新的主节点发起复制操作连接的时间(不包括复制数据的时间)超过timeout，都会导致故障转移超时失败。
        
              默认值是180000，即180s；如果超时，则下一次该值会变为原来的2倍。