# fork()函数
### 基本介绍：

一个进程包括代码、数据和分配给进程的资源

fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。

执行fork()系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。

创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。

每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过getpid（）函数获得，还有一个记录父进程pid的变量，可以通过getppid（）函数获得变量的值。

写时复制策略：当在fork函数发送时，如果父进程进行更改操作（执行一个写命令），操作系统会复制一份给子进程，保证数据不受影响

### fork()函数返回值有2个，一个是父进程（原来的进程）的，一个是子进程（克隆）的
    1）在父进程中，fork返回新创建子进程的进程ID；
    2）在子进程中，fork返回0；
    3）如果出现错误，fork返回一个负值；
    其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0
### fork出错原因：
     1）当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。
     2）系统内存不足，这时errno的值被设置为ENOMEM。

# 
## 特性
### Scan(游标)操作：解决大量key时的key操作阻塞服务器

    SCAN迭代当前所选Redis数据库中的密钥集。
    SSCAN迭代集合类型的元素。
    HSCAN迭代Hash类型及其相关值的字段。
    ZSCAN迭代排序集类型的元素及其相关分数。
    
    redis 127.0.0.1:6379> scan 0
1) "17"     下一个游标为17
2)  1) "key:12"
    2) "key:8"
    3) "key:4"
    4) "key:14"
    5) "key:16"
    6) "key:17"
    7) "key:15"
    8) "key:10"
    9) "key:3"
   10) "key:7"
   11) "key:1"

redis 127.0.0.1:6379> scan 17
1) "0"      下一个游标为0
2) 1) "key:5"
   2) "key:18"
   3) "key:0"
   4) "key:2"
   5) "key:19"
   6) "key:13"
   7) "key:6"
   8) "key:9"
   9) "key:11"
### match选项：过滤器是在从集合中检索元素之后应用的，就在将数据返回到客户端之前
redis 127.0.0.1:6379> scan 0 MATCH *11*
1) "288"
2) 1) "key:911"

redis 127.0.0.1:6379> scan 288 MATCH *11*
1) "224"
2) (empty list or set)

redis 127.0.0.1:6379> scan 224 MATCH *11*
1) "80"
2) (empty list or set)

redis 127.0.0.1:6379> scan 80 MATCH *11*
1) "176"
2) (empty list or set)

redis 127.0.0.1:6379> scan 176 MATCH *11* COUNT 1000
1) "0"
2)  1) "key:611"
    2) "key:711"
    3) "key:118"
    4) "key:117"
    5) "key:311"
    6) "key:112"
    7) "key:111"
    8) "key:110"
    9) "key:113"
   10) "key:211"
   11) "key:411"
   12) "key:115"
   13) "key:116"
   14) "key:114"
   15) "key:119"
   16) "key:811"
   17) "key:511"
   18) "key:11"
      
### 过期键的删除
    如果没有设置过期时间，会一直呆到内存大于maxmemory后执行相应的淘汰策略
    
    1）：立即删除。在设置键的过期时间时，创建一个回调事件，当过期时间达到时，由时间处理器自动执行键的删除操作。（redis不使用）
    2）：惰性删除。键过期了就过期了，不管。每次从dict字典中按key取值时，先检查此key是否已经过期，如果过期了就删除它，并返回nil，如果没过期，就返回键值。
    3）：定时删除。每隔一段时间，对expires字典进行检查，删除里面的过期键。
    
     定时操作：Redis每秒做10次的事情：
            1.从具有相关过期的密钥集中测试20个随机密钥。
            2.删除找到的所有密钥已过期。
            3.如果超过25％的密钥已过期，请从步骤1重新开始。
            
            Redis使用 惰性+定时
### 过期键对内存的影响
    rdb：在创建新的RDB 文件的时候，程序会对键进行检查，过期键不会被写入到更新后的RDB文件中。因此，过期键对更新后的RDB 文件没有影响。
    
    aof:在键已经过期，但是还没有被惰性删除之前，这个键不会产生任何影响，AOF 文件也不会因为这个键而修改，当过期键被惰性删除或者定期删除之后，程序会向AOF 文件追加一条命令，来显示地记录该键已经被删除。
    
    例如：如果客户端使用 GET message 试图访问 message 键的值，但是 message 已经过期了，那么服务器执行以下三个动作：
    从数据库中删除 message
    追加一条 DEL message 命令到 aof 文件
    向客户端返回 nil
    
    aof重写：和 RDB 文件类似，当进行AOF重写时，程序会对键进行检查，过期的键不会被保存到重写后的AOF 问价。因此过期键对重写后的AOF 文件没有影响。
### 发布订阅功能
    1.subscribe（订阅） subscribe msg--用户客户端订阅msg这个频道
      psubscribe(模糊订阅) psubscribe it* --订阅it.news it.blog等频道
    2.publish（发布） publish msg 'hello '--msg这个频道发布消息 'hello'  订阅者都会收到
### 流水线功能（pipeline）
    目的：通过减少客户端与服务器之间的通信次数来提高程序的执行效率。  
    
     一般情况：用户每执行一个 Redis 命令，客户端与服务器都需要进行一次通信：客户端会将命令请求发送给服务器，而服务器则会将执行命令所得的结果返回给客户端。
              客户端在执行 Redis 命令时，大部分等待时间都耗费在了发送命令请求和接收命令回复上面。
              
     解决：流水线功能允许客户端一次将多个命令请求发送给服务器， 并将被执行的多个命令请求的结果在一个命令回复中全部返回给客户端， 使用这个功能可以有效地减少客户端在执行多个命令时需要与服务器进行通信的次数。

## Redis使用场景
    1.缓存
      Redis提供了键值过期时间设置，并且也提供了灵活控制最大内存和内存溢出后的淘汰策略。
      
    2.排行榜系统（sort set）
        排行榜在第一次zadd 或zincrby时创建
        
        设置玩家分数:zadd 排行榜名称 分数 选手
        查询玩家分数:zscore 排行榜名称 选手
        查看排行榜按分数低到高: zrange 排行榜名称 起始位置 结束位置（-1表示查看全部）[withscores:会返回分数]
                  按分数高到低: zrevrange 排行榜名称 起始位置 结束位置（-1表示查看全部）
        查看选手排名按分数低到高:zrank 排行榜名称 选手
                                 zrevrank   
        增减玩家分数:zincrby 排行榜 分数 玩家（若玩家不在排行榜中，则score=0,相当于zadd）  
        移出玩家:zrem 排行榜 玩家
        删除排行榜:del 排行榜 
        
        相同分数问题--加入时间轴
        score=分数+时间轴（score=分数*10000000000 + (9999999999 – timestamp)）
           
    3.计数器应用（incrby）
    
    4.社交网络
      踩/赞(set)、粉丝(sort set)、共同好友/喜好、推动、下拉刷新等社交网站的必备功能，由于社交网站访问量通常比较大，而且传统的关系型输数据不太社和保存这种类型的数据，Redis 提供的数据结构可以相对比较容易地实现这些功能。                   
      Redis提供了列表和有序集合数据结构，合理的使用这些数据结构可以很方便的构建各种排行榜系统。
      
    5.消息队列（list）
## Redis不能做什么？
    1大规模数据和小规模数据，若是大规模数据放在内存中压力过大 不适合
    2.热数据：需要频繁操作的数据 （视频网站的业务）
      冷数据：不需要频繁操作的数据  （视频网站的历史记录）
## 淘汰政策:内存达到最大内存后Redis的操作 maxmemory-policy

    1，noeviction：不执行任何淘汰策略，当达到内存限制的时候客户端执行命令会报错。
    2，allkeys-lru：从所有数据范围内查找到最近最少使用的数据进行淘汰，直到有足够的内存来存放新数据。
    3，volatile-lru：从所有的最近最少访问数据范围内查找设置到过期时间的数据进行淘汰，如果查找不到数据，则回退到noeviction。
    4，allkeys-random：从所有数据范围内随机选择key进行删除。
    5，volatile-random：从设置了过期时间的数据范围内随机选择key进行删除。
    6，volatile-ttl：从设置了过期时间的数据范围内优先选择设置了TTL的key进行删除。

### Maxmemory(最大内存)配置
    运行时：config set maxmemory 100mb 
    配置文件 maxmemory 100mb
    maxmemory 0:无内存限制 64位无限制 32位3G隐士内存   