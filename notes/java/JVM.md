### 内部类

<img src="C:\Users\15521\AppData\Roaming\Typora\typora-user-images\image-20200202194418998.png" alt="image-20200202194418998" style="zoom:50%;" />

![image-20200202194449112](C:\Users\15521\AppData\Roaming\Typora\typora-user-images\image-20200202194449112.png)

内部类以$间隔，匿名内部类则按数字排序。

**访问规则**

1.内部类相当于外部类的成员变量，因此内部类可以直接访问外部类的成员。

**注意：内部类静态方法只能访问外部类静态成员，静态内部类所有方法只能访问外部类静态成员**

2.外部类如果要访问内部类中的成员，**要么内部类是静态的，跟着外部类一起被加载；要么创建内部类的对象，通过对象访问（想让外部类进内部类里面，总得有内部类的“实体”吧，这个“实体”要么是跟外部类一起加载的静态内部类，要么是新建的内部类的对象，无论是哪种，都会在堆中为内部类开辟空间，然后才可以访问到）**

```
内部类没有被static等修饰
Fu.Inner s = new Fu().new Inner();
外部类.内部类 变量名 = new 外部类（）.内部类（）;
--------------------------------
如果被static修饰的静态内部类，就相当于一个外部类
Fu.Inner s = new  Fu.Inner（）；
```

#### 静态内部类

静态内部类虽然也定义在外部类的里面， 但是它只是在形式上（写法上）和外部类有关系， 其实在逻辑上和外部类并没有直接的关系。

#### 普通内部类

形式和逻辑上都和外部类有直接关系。

**为什么内部类可以访问外部类变量？**

1.在内部类Outer$Inner中， 存在一个名字为this$0 ， 类型为Outer的成员变量， 并且这个变量是final的。

 “**编译器自动为内部类添加一个外部类成员变量，指向外部类对象的引用**“

2.编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型。

3.在调用内部类的构造函数初始化内部类对象时， 会默认传入外部类的引用。

### JVM 模式

**HotSpot默认采用一个解释器和一个编译器**

**Server模式：**启动时，速度较慢，启动之后，性能更高，适合运行服务器后台程序。（自带 Server Compiler -C2 编译器）



**Client模式：**启动时，速度较快，性能较低，适合用于桌面的有界面的程序。（自带 Client Compiler -C1 编译器）

### 热点代码

当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认为是“热点代码”。

#### 热点代码检测

##### 采样检测

虚拟机周期性地检测各个线程的栈顶，如果发现某个方法经常出现在栈顶，即为“热点“。

**优点：**实现简单高效，容易获取方法调用关系。

**缺点：**不精确，容易受到线程堵塞或外部因素影响。

##### 计数检测（HotSpot使用）

虚拟机为每个方法（代码块）建立计数器，统计方法的执行次数，超过一定的阀值即为“热点”。

**缺点：**实现麻烦消耗资源，需要为每个方法建立并维护计数器。

###### 计数器种类（协同工作）

**方法调用计数器：**统计方法被调用的次数。

**回边计数器：**统计方法中循环体代码执行次数。

Client模式下是1500 Server模式下是10000

### 字节码、机器码、本地代码

**字节码：class文件，java源文件通过javac命令编译成字节码**

**机器码和本地代码：机器操作系统可以直接识别运行的代码，即机器指令**

字节码不能直接运行，需要经过JVM编译成机器码才能在机器操作系统运行。

**通过将源文件（代码）编译成JVM能够编译成各个机器上能运行的文件（字节码）实现跨平台**

**Java为什么不直接编译成机器码?**

机器码与平台相关，即与操作系统相关，不同操作系统识别不同的机器码。

如果直接编译成机器码，则不能跨平台，无法做到“一次编译，到处运行"。

### 编译与解释？

**编译器：**把源程序的每一条语句都编译成机器语言,并保存成二进制文件,这样运行时计算机可以直接以机器语言来运行此程序,速度很快（全部）

**解释器：**只在执行程序时,才一条一条的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的（一条一条）效率较低。

**字节码-->机器码过程中：JVM采用解释器，JIT采用编译器**

只执行一次的代码，没必要**编译**，直接**解释**即可。

热点代码，反复**解释**很慢，直接**编译**。

**HotSpot两者并存**

解释器：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。

编译器：在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。

两者的协作：在程序运行环境中内存资源限制较大时，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。当通过编译器优化时，发现并没有起到优化作用，，可以通过逆优化退回到解释状态继续执行。

![img](https://upload-images.jianshu.io/upload_images/6753966-b3130d7739d13d86?imageMogr2/auto-orient/strip|imageView2/2/w/700/format/webp)

### 即时编译器JIT

为了提高热点代码的执行效率，运行时，JIT将这些热点代码**编译**成**机器码**。

**当计数器达到阀值后会触发JIT**

当一个方法被调用时，会先检查该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。

如果不存在已被编译过的版本，则将此方法的调用计数器加 1，然后判断**方法调用计数器与回边计数器之和**是否超过方法调用计数器的阈值。如果已经超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。JIT分析此代码为热代码，进行异步编译成本地机器码，把对象分配到栈上。

（如果是server编译器：在前10000次循环和编译成本地机器码这段时间，对象都会在堆中分配对象，编译成本地机器码后才会在栈上分配）

****

### 逃逸分析

逃逸分析：分析对象动态作用域。

当一个对象在方法中被定义后，它可能被外部方法所引用，称为方法逃逸。

被外部线程访问，譬如赋值等操作，称为线程逃逸。

**Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否将这个对象分配到堆上**

```
-XX:+DoEscapeAnalysis开启逃逸分析（jdk1.8默认开启，其它版本未测试）
-XX:-DoEscapeAnalysis 关闭逃逸分析

public class OnStackTest {
    public static void alloc(){
        byte[] b=new byte[2];
        b[0]=1;
    }
    public static void main(String[] args) {
        long b=System.currentTimeMillis();
        for(int i=0;i<100000000;i++){
            alloc();
        }
        long e=System.currentTimeMillis();
        System.out.println(e-b);
    }
}
```

**开启逃逸分析后，对象没有分配在堆上，没有进行GC，而是把对象标量替换后分配在栈上**

**关闭逃逸分析后，对象全部分配到堆上，当堆中对象存满后，进行多次GC，导致执行时间大大延长**

### 栈上分配

方法中的变量和对象分配到栈上，方法执行完后自动摧毁，不需垃圾回收的介入，提高系统性能。

### 同步消除(锁消除)

线程同步比较消耗资源，如果确定一个对象不会逃逸出线程，无法被其它线程访问到，则该对象不存在竞争，则该变量的同步可以擦除。（单线程中没有锁竞争）

```
-XX:+EliminateLocks开启锁消除（jdk1.8默认开启，其它版本未测试）
-XX:-EliminateLocks 关闭锁消除
锁消除基于分析逃逸基础之上，开启锁消除必须开启逃逸分析

public class OnStackTest {
    public static void alloc(){
        byte[] b=new byte[65];
        synchronized (b) {  //同步代码块
            b[0]=1;
        }
    }
    public static void main(String[] args) throws IOException {
        long b=System.currentTimeMillis();
        for(int i=0;i<100000000;i++){
            alloc();
        }
        long e=System.currentTimeMillis();
        System.out.println(e-b);
    }
}
```



### 标量替换

虚拟机中原始数据类型（int long以及reference等）都不能进一步分解，称为标量。

相反如果一个数据可以继续分解，称为聚合量。(JAVA中的对象)

如果逃逸分析一个对象不会被外部访问，并且该对象是可以分解的，那么程序执行时不会创建该对象，而是直接创建它的若干个被这个方法使用到的成员变量来代替。即可以在栈上分配空间而无需在堆中分配。

```
-XX:+EliminateAllocations开启标量替换（jdk1.8默认开启，其它版本未测试）
-XX:-EliminateAllocations 关闭标量替换
标量替换基于分析逃逸基础之上，开启标量替换必须开启逃逸分析
```

**虚拟机通过标量替换实现栈上分配对象，如果关闭标量替换也无法实现栈上分配对象**

### new一个对象 虚拟机做了什么？

#### 1.加载并初始化类

java程序中的 "new" 操作会转化为Class文件中的 "new" 字节码指令

"new" 首先检查是否能够从**常量池中定位到类的符号引用**（类的带路径全名），并且检查这个符号引用代表的**类是否已经被加载、解析、初始化**，即验证是否是第一次使用该类  。

**若不是首次使用该类，进行下一步 创建对象**

**若是首次使用，进行类加载和初始化**

1.加载 2.验证 3.准备 4.解析 5.初始化

#### 2.创建对象

**A.**在堆区分配对象需要的内存

包括本类和父类的所有实例变量，不包括静态变量

**B.**对所有实例变量赋默认值

将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值

**C.**执行实例初始化代码

初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法

**如果有类似于Child c = new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它**



#### **为对象分配内存的方式**

**1.指针碰撞**

假设Java堆的内存是绝对规整的，所有用过的内存都放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲空间那边挪动一段与对象大小相等的距离。

**2.空闲列表**

如果Java堆中的内存并不是规整的，已使用的内存和空间的内存是相互交错的，虚拟机必须维护一个空闲列表，记录上哪些内存块是可用的，在分配时候从列表中找到一块足够大的空间划分给对象使用。

**内存划分的安全性**

有可能出现正在给A对象分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针分配内存的情况。

 1.分配内存空间的动作进行同步处理：实际上虚拟机采用**CAS配上失败重试**的方式保证了更新操作的原子性。

2.内存分配的动作按照线程划分在不同的空间中进行：为每个线程在Java堆中**预先分配一小块内存**，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。



**虚拟机角度的对象初始化**

 内存分配完后，虚拟机需要将分配到的内存空间中的数据类型都初始化为零值（不包括对象头）；接下来虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息都存放在对象的对象头中。

做完以上以后，从虚拟机视角来看，一个新的对象已经产生了，但是Java程序视角来看，执行new操作后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正的对象就产生了。


**句柄访问**

![img](https://img-blog.csdn.net/20180319230104780)

**直接指针访问**

![img](https://img-blog.csdn.net/20180319230115853)

### volatile

**保证可见性 禁止指令重排序**

**内存屏障**

确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；

**强制将对缓存的修改操作立即写入主存**，利用缓存一致性机制，并且缓存一致性机制会阻止同时修改由两个以上CPU缓存的内存区域数据；

如果是写操作，它会导致其他CPU中对应的缓存行无效。

一个处理器的缓存回写到内存会导致其他处理器的缓存失效。

处理器使用**嗅探技术**保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。**例如CPU A嗅探到CPU B打算写内存地址，且这个地址处于共享状态**，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。