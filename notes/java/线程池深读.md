# 线程池深读

## 线程池好处

- **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。
- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。
- **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。
- **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。

## 总体设计

![img](https://picb.zhimg.com/80/v2-e3ba513194a1f918b0abfc42b6fecd0a_1440w.jpg)

**ThreadPoolExecutor工作机制**

![img](https://pic1.zhimg.com/80/v2-4e788c3de25c337889e31ca0e77ceabd_1440w.jpg)

线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。

线程池的运行主要分成两部分：任务管理、线程管理。

任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。

线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。

## 生命周期管理

线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。

```
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
```

`ctl`这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。

**ThreadPoolExecutor运行状态**

![img](https://pic2.zhimg.com/80/v2-9ff88b126bf859ccb751ee1526e97f8c_1440w.jpg)

![img](https://picb.zhimg.com/80/v2-1ec0ca2f5213af7e504847dc1d7a9ccb_1440w.jpg)

## 任务调度

1. 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。
2. 如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。
3. 如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。
4. 如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。
5. 如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。

![img](https://pic1.zhimg.com/80/v2-b06a332965a66469ac512d92ff70e2db_1440w.jpg)

## Worker线程

线程池内的工作线程即为Worker线程

```
private final class Worker extends AbstractQueuedSynchronizer implements Runnable{
    final Thread thread;//Worker持有的线程
    Runnable firstTask;//初始化的任务，可以为null
}
```

![img](https://picb.zhimg.com/80/v2-8b9dde8b5f4b7c1cce2fe9701444779c_1440w.jpg)

当firstTask不为null时，执行任务，否则获取任务队列中的任务执行。

**管理线程的生命周期**

线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。

**判断线程是否处于运行状态**

Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。

1. lock方法一旦获取了独占锁，表示当前线程正在执行任务中。
2. 如果正在执行任务，则不应该中断线程。
3. 如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。
4. 线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。

![img](https://picb.zhimg.com/80/v2-3f0278cea6d3f910d5f9b5149125c57a_1440w.jpg)

### Worker线程回收

线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，**核心线程可以无限等待获取任务，非核心线程要限时获取任务**。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。

```text
try {
  while (task != null || (task = getTask()) != null) {
    //执行任务
      try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
  }
} finally {
  processWorkerExit(w, completedAbruptly);//获取不到任务时，主动回收自己
}
```

```
public Runnable getTask(){
 boolean timed = allowCoreThreadTimeOut || wc > corePoolSize; 
Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                        if (r != null)
                    return r;
}
```

线程回收的工作是在processWorkerExit方法完成的。

![img](https://pic3.zhimg.com/80/v2-0d9370779a75f96deabdc4c028b85009_1440w.png)

事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。

    private void processWorkerExit(Worker w, boolean completedAbruptly) {
        try {
            completedTaskCount += w.completedTasks;
            //删除当前线程
            workers.remove(w);
        } finally {
            mainLock.unlock();
        }
        if (runStateLessThan(c, STOP)) {
            //创建一个空的工作线程
            addWorker(null, false);
        }
    }
#### 核心线程不会被回收的原理

从阻塞任务队列中取任务，如果设置了allowCoreThreadTimeOut(true) 或者当前运行的任务数大于设置的核心线程数，那么timed =true 。此时将使用workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)从任务队列中取任务，而如果没有设置，那么使用workQueue.take();取任务，对于阻塞队列，poll(long timeout, TimeUnit unit) 将会在规定的时间内去任务，如果没取到就返回null。take()会一直阻塞，等待任务的添加。

因此核心线程调用take方法堵塞直到获取任务。

#### 当任务逻辑出现异常抛出时

从上面源码可知，当我们编写的run方法中抛出异常时，Worker线程也会自行回收

#### **关键**

线程池根本没对任何线程进行特殊标记核心与非核心，也没有核心线程不被销毁的说法，**线程池只是销毁多余的空闲线程而已**。所有的线程在运行的过程中都有可能在这两种状态中来回变换。

```
boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
```

**举例**

刚开始某个线程是核心线程，获取到任务后执行任务，执行完成后再次getTask时，这时假如线程数已经大于核心线程数了，那么该线程就会变成非核心线程，执行poll而不是take操作。

### Worker线程执行任务

1. while循环不断地通过getTask()方法获取任务。
2. getTask()方法从阻塞队列中取任务。
3. 如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。
4. 执行任务。
5. 如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。

![img](https://pic3.zhimg.com/80/v2-39e62ca6c230d48549f08092d29ab547_1440w.jpg)

### 线程池线程发生异常会立刻抛出吗

不会，会得到调用 `Future.get()`方法获取回调时才抛出

### 发生异常的核心线程还会继续使用吗

不会，线程结束，会重新创建线程代替

### submit runnable返回值？

`FutureTask`对 `runnable` 线程转化到 `callable`，这个callable的call()的结果永远是result。

`submit(Runnable task)` get值为null

`submit(Runnable task, T result)` get值为 result

### get方法堵塞

在调用submit提交任务之后，主线程本来是继续运行了。但是运行到future.get()的时候就阻塞住了，一直等到任务执行完毕，拿到了返回的返回值，主线程才会继续运行。因为调用get()方法时，任务还没有执行完，所以会一直等到任务完成，形成了阻塞。

### 异常

使用submit方法还有一个特点就是，他的异常可以在主线程中catch到。

而使用execute方法执行任务是捕捉不到异常的。

### 拒绝策略

四种拒绝策略都实现于 `RejectedExecutionHandler`

`DiscardOldestPolicy`

首先通过 `poll` 扔掉最旧的任务，然后将新的任务放入线程池

```

            if (!e.isShutdown()) {
                e.getQueue().poll();
                e.execute(r);
            }
```

`AbortPolicy`

抛出异常丢弃任务

```
   throw new RejectedExecutionException("Task " + r.toString() +                                         " rejected from " +                                         e.toString());}
```

`CallerRunsPolicy`

该任务由调用者线程执行

```
if (!e.isShutdown()) {    r.run();}
```

`DiscardPolicy`

什么都没做，当作该任务没来过

```

```

**自定义拒绝策略**

只需实现 `RejectedExecutionHandler` 接口，并重写 `rejectedExecution` 方法即可。