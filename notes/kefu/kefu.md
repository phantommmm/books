## 背景

•     旧的客服会话系统因使用第三方而导致无法呈现**各业务的用户信息**，导致客服服务效率缓慢

•     其次，第三方会话系统接入方式不完善，而导致流失率较高

•     随着公司自研IM日趋完善，客服会话系统可采用公司自研IM为用户提供在线客服能力

## 目标

自己开发能够自定义功能，以及维护用户数据。

•     客服会话系统平台化，为公司其它C端应用提供在线客服能力

•     提供注入C端用户信息能力，提高客服工作效率

•     简化用户接入流程，提供游客模式，提高用户接入在线客服效率，降低流失率

•     提供一键切换底层IM工具能力，方便后期切换公司自研IM工具，降低成本

•     实时**抄送保存客服与用户聊天记录、评价记录、咨询分类，为运营提供数据分析能力**

## 接入流程

<img src="../AppData/Roaming/Typora/typora-user-images/image-20200801152337319.png" alt="image-20200801152337319" style="zoom: 200%;" />



## 应用授权模块

### **一.获取AppKey+AppSecret（目前暂无访问接口，可以使用HTTPS SSL握手生成密匙）**

**请求参数** appName+accId（多个应用可属于同一个accId）

**返回值** appKey+appSecret

**1.** appName+accId -- > appKey+appSecret

appKey=加密(appName+accId)

appSecret=加密(appKey+appId)

然后redis.set(appKey,appSecret) 并且数据库存储

**appSecret主要用于后面应用信息加密**

### **二.获取客服平台appUserToken应用用户凭证 （通过http接口）**

每个在App登录的用户在进入客服平台时，都会向客服平台申请一个appUserToken，用于校验用户信息、安全校验和区分游客；未在APP登录的用户无需获取appUserToken，在客服平台为游客身份

**请求参数** appkey+userId+nonce+timestamp+signature

**返回值** appUserToken

timestamp时间戳 nonce随机数 signature=(timestamp+nonce+appKey)利用appSecret加密

**1.验证appKey**  

根据appKey去Redis中获取Secret，若无则返回失败

**2.加密验证** 

加密(appkey + timestamp + nonce)==signature？利用相同的appSecret加密

**3.生成Token**

加密(appkey+userId) -- > appUserToken

然后redis.set(appKey,UserId)

返回Token

**作用**

用于校验用户信息、安全校验和**区分游客**



**nonce作用**

防重放攻击，若时间戳被拦截，则添加随机数加大伪造的难度，可将每次请求的随机数保存到数据库中，每次访问时首先判断随机数是否存在，存在则表明该请求可能为恶意请求。

**timestamp作用**

防复用，通过时间戳来避免被重复请求，造成服务器压力大问题。

Timestamp是根据服务器当前时间生成的一个字符串，与nonce放在一起，可以表示服务器在某个时间点生成的随机数。这样就算生成的随机数相同，但因为它们生成的时间点不一样，所以也算有效的随机数。

**问题**

数据库nonce数量会逐渐增大，对数据添加过期时间，比如说在数据库中保存超过一天的数据将会被清除。如果是这样，攻击者可以等待一天后，再将拦截到的HTTP报文提交到服务器，这时候因为nonce/timestamp/username数据已被服务器清除，请求将会被认为是有效的。

要解决这个问题，就需要给时间戳设置一个超时时间，比如说将时间戳与服务器当前时间比较，如果相差一天则认为该时间戳是无效的。

## 登录模块

### **三.登录token**

cookie中如果已经有客服平台的token，则不再需要走登录流程；cookie中没有token时才走登录流程

**请求参数** appkey+userId+appUserToken

**返回值** Token

验证appkey以及appUserToken是否存在，

<img src="../AppData/Roaming/Typora/typora-user-images/image-20200801155439697.png" alt="image-20200801155439697" style="zoom:200%;" />

### Refresh Token

本意就是想解决「用户已经授权一次，标识信任了，那么以后就尽量少再要求用户授权」。

refreshtoken的作用是，当你拿到的accesstoken快要过期之前，你可以使用这个refreshtoken直接向服务器「再要一次accesstoken」。不然的话，accesstoken过期额，你就又需要用户授权一次了。

**会话流程**

1.客户端使用用户名密码进行认证

2.服务端生成有效时间较短的 Access Token（例如 10 分钟），和有效时间较长的 Refresh Token（例如 7 天）

3.客户端访问需要认证的接口时，携带 Access Token

4.如果 Access Token 没有过期，服务端鉴权后返回给客户端需要的数据

5.如果携带 Access Token 访问需要认证的接口时鉴权失败（例如返回 401 错误），则客户端使用 Refresh Token 向刷新接口申请新的 Access Token

6.如果 Refresh Token 没有过期，服务端向客户端下发新的 Access Token

7.客户端使用新的 Access Token 访问需要认证的接口

将生成的 Refresh Token 以及过期时间存储在服务端的数据库中，由于 Refresh Token 不会在客户端请求业务接口时验证，只有在申请新的 Access Token 时才会验证，所以将 Refresh Token 存储在数据库中，不会对业务接口的响应时间造成影响，也不需要像 Session 一样一直保持在内存中以应对大量的请求。

Refresh_token的作用是刷新AccessToken。认证服务器会提供一个刷新接口，我们传入Refresh_token和client_id，认证服务器通过后会返回一个新的AccessToken。但是为了安全，Oauth2.0引入了两个措施：
1，要求refresh_token必须保存在客户端的服务器上，调用refresh_token的时候一定是从服务器到服务器的访问。
2，OAuth2引入了Client_Secret机制。每一个Client_id,都对应一个Client_Secret。这个Client_Secret会在客户端申请Client_id时，随Client_id一起分配给客户端。客户端把他们都保存在服务器上，刷新Refresh_token时，需要验证这个Client_Secret。

### RSA简介

RSA是一种非对称性加密。通过 **公钥** 和 **私钥** 进行加密解密。

### 加密与签名

**加密** 是为了防止信息被泄露。

RSA的加密过程如下：

（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。

（2）A传递自己的公钥给B，B用A的公钥对消息进行加密。

（3）A接收到B加密的消息，利用A自己的私钥对消息进行解密。

　　在这个过程中，只有2次传递过程，第一次是A传递公钥给B，第二次是B传递加密消息给A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。

**签名** 是为了防止信息被篡改

RSA签名的过程如下：

（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。

（2）A用自己的私钥对消息加签，形成签名，并将加签的消息和消息本身一起传递给B。

（3）B收到消息后，在获取A的公钥进行验签，如果验签出来的内容与消息本身一致，证明消息是A回复的。

　　在这个过程中，只有2次传递过程，第一次是A传递加签的消息和消息本身给B，第二次是B获取A的公钥，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行签名，即使知道了消息内容，也无法伪造带签名的回复给B，防止了消息内容的篡改。

**总结 公钥加密、私钥解密、私钥签名、公钥验签。**

**PS: **RSA加密对明文的长度有所限制，规定需加密的明文最大长度=密钥长度-11（单位是字节，即byte），所以在**加密和解密的过程中需要分块进行**。而密钥默认是1024位，即1024位/8位-11=128-11=117字节。所以默认加密前的明文最大长度117字节，解密密文最大长度为128字。那么为啥两者相差11字节呢？是因为RSA加密使用到了填充模式（padding），即内容不足117字节时会自动填满，用到填充模式自然会占用一定的字节，而且这部分字节也是参与加密的。

### 项目实际

<img src="https://pic002.cnblogs.com/images/2012/379997/2012030522491911.png" alt="img" style="zoom:50%;" />

1.用户请求登录页面，服务器生成对应的 **公钥** 和 **私钥**，将 **公钥** 返回给浏览器，**私钥** 用Map/redis或mysql保存。（key 为公钥 value 为私钥）

2.用户 用 **公钥** 对密码进行加密 发给 服务器。

3.服务器用 **私钥** 解密 判断。

### 为什么不用MD5（区别）？

理论上讲，rsa基于大质数分解的复杂度远高于md5+salt。

实际上，md5+salt比rsa更适合。

1、不可能对所有的用户建立一个私钥，主要原因是管理复杂（基于安全的考虑不可能把私钥存在数据库中，那存储密码的复杂度就从保存密码本身变成了安全保存所有私钥）

2、如果只设计一个master私钥的话，所有密码验证共用一个私钥会带来更多的安全问题（第一点安全保存私钥的问题和master泄密的问题）

而使用md5+salt的隐患是彩虹表攻击，但是由于salt是随机生成的，作为明文和md5(passwd+salt)一起存放在数据库中，可以让所有用户密码泄漏的概率从O(N)变成O(N)*用户数（这里O(N)是指彩虹表破解一个用户密码的复杂度）。在绝大部分安全等级没那么高的系统中，这样设计已经足够满足需求了。

### DES

DES加密算法是一种分组密码，以64位为分组对数据加密，它的密钥长度是56位，加密解密用同一算法。DES加密算法是对密钥进行保密，而公开算法，包括加密和解密算法。这样，只有掌握了和发送方相同密钥的人才能解读由DES加密算法加密的密文数据。因此，破译DES加密算法实际上就是搜索密钥的编码。对于56位长度的密钥来说，如果用穷举法来进行搜索的话，其运算次数为2的56次方

### AES

DES与AES之间的主要区别在于加密过程。在DES中，将明文分为两半，然后再进行进一步处理；而在AES中，整个块不进行除法，整个块一起处理以生成密文。
相对而言，AES比DES快得多，并且与DES相比，AES能够在几秒钟内加密大型文件。

由于DES中使用的共享密钥的比特大小较小，因此它被认为不如AES安全。DES被认为更容易受到暴力攻击，而到目前为止，尚未遇到任何严重攻击的AES。

AES比DES更具灵活性，因为它允许包括128、192、256位在内的各种长度的文本，而DES允许对64位固定文本进行加密。
DES回合处理中使用的功能是扩展，置换和替换，具有回合键的XOR操作，而AES回合中使用的功能是子字节，移位行，混合列和添加回合键。
AES实际上在硬件和软件实现上都是高效的，而DES最初只在硬件上有效。

## 游客池



![image-20200812183803044](../AppData/Roaming/Typora/typora-user-images/image-20200812183803044.png)

使用List结构，初始化时，LPUSH左侧放进去 信息为 游客id

从临时用户池中 RPOP 右侧拿走

从游客池中移除时，先通过 lrem 根据key移除队列，然后在临时用户池中Lpush

1.申请创建应用时会自动创建游客池；

2.当用户登录客服平台时，appUserToken为空，则为临时用户，此时从游客池随机分配一个user给用户，并把分配的user放到临时用户池中（从游客池中删除user,在临时用户池中添加user）；

3.当结束会话时，从临时用户池中删除user,在游客池中添加user

## 客服平台同步用户信息

| 用户信息同步方式      | 描述                                                         | 优点                                                         | 缺点                                                         |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| App客户端同步（使用） | App客户端在用户连接客服平台时将用户信息传入KefuSdk，由KefuSdk在登录时同步到KefuServer保存 | 1.不用批量同步App用户信息，只在用户请求客服平台时保存用户信息；  2.用户信息查KefuServer自己的库，查询效率更高；  3.App客户端可控制是否传入用户信息，不传入则为游客； | 1.如果App用户信息更改，客服平台需要同步维护更新用户信息；    |
| AppServer回调同步     | App在申请接入时可配置AppServer查询用户信息的回调地址，KefuServer可根据回调地址查询用户信息 | 1.AppServer可灵活控制是否传入用户信息；                      | 1.AppServer需提供公网访问的API接口，增加AppServer工作量，且需做安全校验；  2.依赖AppServer接口的稳定性；  3.若KefuServer不保存用户信息，则需通过AppServer API接口实时查询；  4.若KefuServer保存用户信息，则用户每次请求客服平台时都需更新用户信息； |
| AppServer同步         | AppServer调用KefuServer暴露的API接口同步用户信息到KefuServer保存；如有更新用户信息，调用KefuServer更新API接口更新用户信息 | 1.用户信息查KefuServer自己的库，查询效率更高；  2.AppServer可控制是否传入用户信息，不传入则为游客； | 1.AppServer需批量同步和更新用户信息，增加AppServer工作量；   |

## 会话转接

1.用户建立连接后通过IM工具直接和客服A进行会话；

2.客服A发送转接请求将用户转接给客服B；

3.KefuServer收到转接请求，建立客服B和用户的会话连接，并将用户的历史会话记录同步给客服B

4.客服B和用户建立连接后，通过IM工具实时会话  

# EXCEL

## poi

使用poi组件解析时容易出现OOM问题，原因是POI使用一次性全部加载到内存中，创建的 sheet row cell等对象是存在于内存中并且没有持久化的，所以若是大文件，随着数据量增大内存需求量也会增大直到OOM。

**SAX**，它是Simple API for XML的缩写，主要用在**读文件**， SAX在概念上与DOM完全不同。它不同于DOM的文档驱动，它是事件驱动的，它并不需要读入整个文档，而文档的读入过程一行一行解析。所谓**eventmodel**（事件驱动），将一行的解析结果以观察者的模式通知处理，通知的方式基于回调（callback）机制的程序运行方法。

**XSSF** 

创建的 sheet row cell等对象是存在于内存中并且没有持久化的，所以若是大文件，随着数据量增大内存需求量也会增大直到OOM。

**SXSSF**

设置最大内存条数。比如：设置最大内存量为5000 rows（new SXSSFWookbook（5000））或者手动flush()，此时当行数达到 5000 时，把内存中的数据写到文件中，以此逐步写入避免OOM,那么这样 就完美解决了大数据下导出的问题。

*SXSSFWorkbook.**setCompressTempFiles**(true)，*SXSSF将sheet data刷新到临时文件（每张sheet一个临时文件）中，并且这些临时文件的大小可以增长到非常大的值。

## easy excel

![img](https://img2018.cnblogs.com/i-beta/1847273/201911/1847273-20191126183240680-1871736442.png)

easyexcel最大支持行数1048576

easyExcel解析实在磁盘上进行的，几乎可以将几mb级别的内存压缩到kb级别，几乎不用担心OOM；

easyExcel中有一个类AnalysisEventListener，里面有一个方法invoke实现了一行一行返回，另外还可以重写该类的doAfterAllAnalysed方法，用来做事后处理之类的操作，相当的灵活。

SAX事件解析器，底层在磁盘中解析文件并一行一行的读取，并且会依次执行

# Cookie

**怎么防止cookie攻击（cookie安全问题）**

1.设置httponly,只能通过服务端访问，客户端不能访问，浏览器上看不到。

2.设置secure，只能在https中发送。



# Web攻击

## CSRF 跨站点请求伪造

- CSRF 跨站请求伪造（英语：Cross-site request forgery），是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。如： 
- 攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 
- 大多数用户并不能保证：  
  - 不能保证**关闭浏览器了后，本地的Cookie立刻过期，上次的会话已经结束** 
  - 不能保证登录了一个网站后，不再打开一个tab页面并访问另外的网站 

### CSRF 的攻击类型

- GET类型的CSRF

  - GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：在受害者访问含有这个img的页面后，浏览器会自动向

    http://bank.example/withdraw?account=xiaoming&amount=10000&for=hacker发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求

    [复制代码](#)

    `<img src=``"http://bank.example/withdraw?amount=10000&for=hacker"` `>`

- POST类型的CSRF

  :  

  - 这种类型的CSRF利用起来通常使用的是一个自动提交的表单，访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，**后端接口不能将安全寄托在仅允许POST上面** 

- 链接类型的CSRF

  ：  

  - 这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击 

### CSRF的特点

- 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生 
- 攻击**利用受害者在被攻击网站的登录凭证，冒充受害者提交操作**；而不是直接窃取数据。 
- CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。 

### CSRF与 XSS 区别

- **通常来说 CSRF 是由 XSS 实现的**，CSRF 时常也被称为 XSRF 
- 本质上讲，**XSS 是代码注入问题，CSRF 是 HTTP 问题**，XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(**Token验证可以避免**) 

### CSRF防御

- **token**；token 验证的 CSRF 防御机制是公认最合适的方案。但若网站同时存在 XSS 漏洞的时候，这个方法也是空谈 
- 验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 csrf，但是用户体验比较差 
- Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险 

## XSS攻击

- **XSS全称cross-site scripting（跨站点脚本）**，是一种**代码注入攻击**，是当前 web 应用中最危险和最普遍的漏洞之一。**攻击者向网页中注入恶意脚本，当用户浏览网页时，脚本就会执行，进而影响用户**，比如关不完的网站、盗取用户的 cookie 信息从而伪装成用户去操作，危害数据安全。 

### XSS分类

- 反射型XSS（非持久性跨站攻击）
  - 利用网站某些页面会直接输出请求参数的特性，**通过在url的请求参数包含恶意脚本**，诱使用户点击嵌入恶意脚本的url链接执行恶意脚本以达到攻击的目的。目前有很多攻击者利用论坛、[微博]()发布含有恶意脚本的URL就属于这种方式。 
  - 比如访问链接：https://wqs.jd.com/index.html?content=alert(1) 页面当中执行了，document.getElementById("content").innerHTML = content; 然而这个content是参数传过来的，那么就触发了反射型 XSS 
- 存储型XSS（持久性跨站攻击）
  - **通过表单输入（比如发布文章、回复评论等功能中）插入一些恶意脚本，并且提交到被攻击网站的服务器数据库中**。当用户浏览指定网页时，恶意脚本从数据库中被加载到页面执行，QQ邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台。 
  - 与反射型 XSS 相比，该类的攻击更具有危害性，因为它影响的不只是一个用户，而是大量用户，而且该种类型还可进行蠕虫传播。 
- DOM Based XSS（基于 dom 的跨站点脚本攻击）
  - 通过前面两种类型的方式，注入的脚本是通过改变 DOM 来进行攻击的。采用该种方式有一个好处就是从源代码中不易被发现。 
  - DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于[前端]() [JavaScript]() 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞 

### XSS攻击防范

- 产生xss攻击漏洞主要是因为服务器没有对用户输入进行编码和过滤。另一个原因是，这种攻击方法有很多变体，攻击的手法却不断翻新，要设计出一个能完全防御的XSS过滤器是非常困难的。 
- **防范xss攻击的原则就是不相信用户输入的数据** 

1. HttpOnly
   - 将重要的cookie标记为http only, ，**浏览器将禁止页面的 [JavaScript]() 访问带有 HttpOly 属性的 Cookie**。 
   - HttpOnly 主要是为了解决 XSS 之后的 Cookie 劫持，使用 HttpOnly 有助于缓解 XSS 攻击，防止被窃取敏感的 Cookie信息，本质上不是为了解决 XSS。 
2. 消毒  
   - **在输入输出时对数据进行转义**，比如<转义成<,这样脚本就运行不了了 
   - 录入数据设置白名单，比如javaWeb[项目]()，**设置过滤器过滤特殊字符** 
   - **[前端]()页面限制用户输入数据类型**，比如用户输入完年龄后验证输入内容只能是数字 
   - **过滤JS事件的标签**，比如onclick、load等