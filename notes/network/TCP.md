# TCP

## 计时器

### 重传计时器

**当TCP发送报文段时，就创建该特定报文段的重传计时器** 。可能发生两种情况： 
  （1）、若在计时器截止时间到（ **通常是60秒** ）之前收到了对此特定报文段的确认ACK，则撤销此计时器。 
  （2）、若在收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。

### 保活计时器（keepAlive）

**检测只连接不传输数据的连接并释放**

每当服务器收到客户的信息，就将计时器复位。保活计时器 **通常设置为2小时** 。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段（每一个相隔75秒）还没有响应，就假定客户出了故障，因而就终止该连接。 +

### 2MSL计时器

在第四次挥手时启动使用，2MSL为一个报文在发送和接收的最大时间，目的是为了保证最后一个ACK能够按时到达服务端。

### 坚持计时器

应当TCP零窗口大小通知，使用坚持计时器。

TCP为每一个连接使用一个坚持计时器。 当发送TCP方收到一个窗口大小为零的确认时，就启动坚持计时器 。 当坚持计时器期限到时，发送TCP就发送一个特殊的报文段，叫做 探测报文段 。这个报文段只有一个字节的数据。对端收到后响应出当前的窗口值。

## 标志位

`SYN(synchronous建立联机)`  用于建立连接

`ACK(acknowledgement 确认)`  确认标志，确认接受到数据

`FIN(finish结束)`  终止标志，断开连接

`RST(reset重置)`  表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；

`URG(urgent紧急)` 告诉接收端在一个发送的IP数据包中某特定的数据是紧急的，需要优先处理。如果URG控制位置1，接收端就会分析紧急指针（IP报头中用一个16位的二进制表示），这个指针说明从首个字节开始多少个字节的数据是需要紧急处理的。

`PSH(push传送)`  指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队

## MSS

MSS只包括TCP数据大小而不包括其它TCP IP头部大小。

**MSS怎么确定大小的？**

1.通过TCP双方握手时SYN包中的MSS头部协商MSS大小

2.它并不是任何条件下都可协商。如果一方不接收来自另一方的MSS值，则MSS就定为默认值536字节（这个默认值允许20字节的I P首部和20字节的TCP首部以适合576字节I P数据报)。

**最大MSS？**

MSS收到MTU的限制，以太网中MTU最大为1500 所以最大MSS=1500-20（TCP头）-20（IP头）=1460

## 伪首部

伪首部用于校验TCP、UDP报文，既不上传也不下传，为**校验和**的一步。

**作用** 让UDP两次检查数据是否已经正确到达目的地

伪首部字段：32位源IP地址、32位目的IP地址、8位协议、16位UDP长度。

第一次，通过伪首部的IP地址检验，UDP可以确认该数据报是不是发送给本机IP地址的；

第二，通过伪首部的协议字段检验，UDP可以确认IP有没有把不应该传给UDP而应该传给别的高层的数据报传给了UDP。从这一点上，伪首部的作用其实很大。

## 糊涂窗口SWS

当发送端应用进程产生数据很慢、或接收端应用进程处理接收缓冲区数据很慢，或二者兼而有之；就会使应用进程间传送的报文段很小，特别是**有效载荷**很小。极端情况下，有效载荷可能只有1个字节；而传输开销有40字节(20字节的IP头+20字节的TCP头) 这种现象就叫糊涂窗口综合症。

### Negle算法

Nagle算法是为了尽可能发送大块数据，避免网络中充斥着许多小数据块，提高网络传输效率，即有效载荷大的数据。

Nagle算法的基本定义是任意时刻，一个TCP连接最多只能有一个未被确认的小段，在未收到ACK前不能发送其它小段，收集**少量的小分组**，并在收到ACK后以**一个分组**发出去。

所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。

**优点**

该算法的优越之处在于它是自适应的，确认到达的越快，数据也就发送的越快；而在希望减少微小分组数目的低速广域网上，则会发送更少的分组；

**Negle与延迟ACK产生的问题**

PC1和PC2进行通信，PC1发数据给PC2，PC1使用Nagle算法，PC2有delay ACK机制

1. PC1发送一个数据包给PC2，PC2会先不回应，delay ACK

2. PC1再次调用send函数发送小于MSS的数据，这些数据会被保存到Buffer中，等待ACK，才能再次被发送

从上面的描述看，显然已经死锁了，PC1在等待ACK，PC2在delay ACK，那么**解锁的代价就是Delay ACK的Timer到期**，至少40ms[40ms~500ms不等]，也就是2种算法在通信的时候，会产生不必要的延时！

**解决**

1.使用 `TCP_NODELAY` 选项可以关闭Nagle算法

2.避免使用 write-write-read方式，可以使用 write-read-write-read方式替代

## RTT RTO

**RTT**  数据的往返时间，即数据发送时刻到接收到确认的时刻的差值；

由三个部分决定：即链路的[传播时间](https://baike.baidu.com/item/传播时间)、末端系统的处理时间以及[路由器](https://baike.baidu.com/item/路由器)的缓存中的排队和处理时间。其中，前面两个部分的值作为一个TCP连接相对固定，路由器的缓存中的排队和处理时间会随着整个[网络拥塞](https://baike.baidu.com/item/网络拥塞)程度的变化而变化。所以RTT的变化在一定程度上反映了网络拥塞程度的变化。 

**RTO** 重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。

**时延** 数据报从一端到另一端的时间